# babygame01

## Enoncé
Catégorie : [Binary Exploitation](../)

Points : 100

Tags : `game`

Description :
> Get the flag and reach the exit.  
> Welcome to BabyGame! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you'll have to figure your way around the map. You can connect with it using `nc saturn.picoctf.net xxxxx`.

Hints :
1. Use 'w','a','s','d' to move around.
2. There may be secret commands to make your life easy.


## Approche

Le fichier `game` mis à disposition est un exécutable binaire :
```bash
{ picoCTF_2023 }  » file game

game: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=85fcad170460434c915b5ad675a351a2778e24bb, for GNU/Linux 3.2.0, not stripped
```

Comme les informations de debug ne sont pas incluses, un outil de Reverse Engineering semble nécessaire pour comprendre l'algorithme implémenté.

On peut par exemple utiliser [Ghidra](https://ghidra-sre.org/) élaboré par la NSA pour effectuer cette tâche et ainsi obtenir le code C correspondant.

L'analyse du code montre la présence d'une fonction `win` qui restitue le contenu du fichier `flag.txt`.

L'appel à cette fonction est conditionné, au niveau du `main`, par le fait que la variable `local_aa4`, de type `char`, ait une valeur différente de `'\0'` :
```c
if (local_aa4 != '\0') {
  puts("flage");
  win();
  fflush(stdout);
}
```

On trouve également au niveau de la fonction `move_player`, le déplacement `p` qui permet d'aller directement au "trésor" (i.e. la X sur la carte en coordonnées (29,89)).


## Solution

L'allocation mémoire des variables locales sur la stack au niveau de la fonction `main` est la suivante :

```txt
*************************************************************
*                           FUNCTION
*************************************************************
undefined  main (undefined1  param_1 )
undefined         AL:1           <RETURN>
undefined1        Stack[0x4]:1     param_1
undefined4        Stack[0x0]:4   local_res0
undefined1        Stack[-0x10]:1 local_10
undefined4        Stack[-0x14]:4 local_14
undefined1        Stack[-0xaa0   local_aa0
undefined1        Stack[-0xaa4   local_aa4
undefined4        Stack[-0xaa8   local_aa8
undefined4        Stack[-0xaac   local_aac
```

Donc la variable `local_aa4` est située 4 octets plus bas que la variable `local_aa0` (utilisée pour stocker la carte) au niveau de la stack.

Or la fonction `move_player` ne comporte aucun contrôle pour s'assurer que le déplacement demandé ne sort pas de la carte.

Ainsi, si on se positionne en coordonnées (0,0) et qu'on effectue 4 déplacements vers la gauche (via `a`), on atteint alors l'emplacement mémoire où `local_aa4` est stockée. Cet emplacement est alors valorisé avec le caractère identifiant le joueur (i.e. par défaut `@` soit 0x40). La condition `local_aa4 != '\0'` devient valide.

Il suffit alors d'effectuer le mouvement `p` pour atteindre la sortie et le flag.
